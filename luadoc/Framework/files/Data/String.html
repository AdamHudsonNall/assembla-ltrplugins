<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
    <title>Reference</title>
    <link rel="stylesheet" href="../../luadoc.css" type="text/css" />
	<!--meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/-->
</head>

<body>
<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->

<div id="main">

<div id="navigation">


<h1>LuaDoc</h1>
<ul>
	
	<li><a href="../../index.html">Index</a></li>
	
</ul>


<!-- Module list -->



<!-- File list -->

<h1>Files</h1>
<ul>

	<li>
		<a href="../../files/Catalog/Catalog.html">Catalog/Catalog.lua</a>
	</li>

	<li>
		<a href="../../files/Catalog/MetadataManager.html">Catalog/MetadataManager.lua</a>
	</li>

	<li>
		<a href="../../files/Communication/Ftp.html">Communication/Ftp.lua</a>
	</li>

	<li>
		<a href="../../files/Communication/XmlRpc.html">Communication/XmlRpc.lua</a>
	</li>

	<li>
		<a href="../../files/Data/Boolean.html">Data/Boolean.lua</a>
	</li>

	<li>
		<a href="../../files/Data/DateTime.html">Data/DateTime.lua</a>
	</li>

	<li>
		<a href="../../files/Data/Number.html">Data/Number.lua</a>
	</li>

	<li><strong>Data/String.lua</strong></li>
	
	<li>
		<a href="../../files/Data/Table.html">Data/Table.lua</a>
	</li>

	<li>
		<a href="../../files/Data/Xml.html">Data/Xml.lua</a>
	</li>

	<li>
		<a href="../../files/ExportAndPublish/Export.html">ExportAndPublish/Export.lua</a>
	</li>

	<li>
		<a href="../../files/FileSystem/Disk.html">FileSystem/Disk.lua</a>
	</li>

	<li>
		<a href="../../files/Gui/DelayedProgressScope.html">Gui/DelayedProgressScope.lua</a>
	</li>

	<li>
		<a href="../../files/Gui/Dialog.html">Gui/Dialog.lua</a>
	</li>

	<li>
		<a href="../../files/Gui/Gui.html">Gui/Gui.lua</a>
	</li>

	<li>
		<a href="../../files/Gui/Manager.html">Gui/Manager.lua</a>
	</li>

	<li>
		<a href="../../files/Gui/ScrollView.html">Gui/ScrollView.lua</a>
	</li>

	<li>
		<a href="../../files/Gui/View.html">Gui/View.lua</a>
	</li>

	<li>
		<a href="../../files/Gui/_ClassDebug.html">Gui/_ClassDebug.lua</a>
	</li>

	<li>
		<a href="../../files/Gui/_Load.html">Gui/_Load.lua</a>
	</li>

	<li>
		<a href="../../files/Gui/_Manager.html">Gui/_Manager.lua</a>
	</li>

	<li>
		<a href="../../files/Gui/_ScrollView.html">Gui/_ScrollView.lua</a>
	</li>

	<li>
		<a href="../../files/Image/JpegUtils.html">Image/JpegUtils.lua</a>
	</li>

	<li>
		<a href="../../files/Image/TiffUtils.html">Image/TiffUtils.lua</a>
	</li>

	<li>
		<a href="../../files/System/App.html">System/App.lua</a>
	</li>

	<li>
		<a href="../../files/System/Background.html">System/Background.lua</a>
	</li>

	<li>
		<a href="../../files/System/Call.html">System/Call.lua</a>
	</li>

	<li>
		<a href="../../files/System/Debug.html">System/Debug.lua</a>
	</li>

	<li>
		<a href="../../files/System/DebugScript.html">System/DebugScript.lua</a>
	</li>

	<li>
		<a href="../../files/System/Globals.html">System/Globals.lua</a>
	</li>

	<li>
		<a href="../../files/System/InitFramework.html">System/InitFramework.lua</a>
	</li>

	<li>
		<a href="../../files/System/LogFile.html">System/LogFile.lua</a>
	</li>

	<li>
		<a href="../../files/System/Mac.html">System/Mac.lua</a>
	</li>

	<li>
		<a href="../../files/System/Object.html">System/Object.lua</a>
	</li>

	<li>
		<a href="../../files/System/ObjectFactory.html">System/ObjectFactory.lua</a>
	</li>

	<li>
		<a href="../../files/System/OperatingSystem.html">System/OperatingSystem.lua</a>
	</li>

	<li>
		<a href="../../files/System/Preferences.html">System/Preferences.lua</a>
	</li>

	<li>
		<a href="../../files/System/Properties.html">System/Properties.lua</a>
	</li>

	<li>
		<a href="../../files/System/Reload.html">System/Reload.lua</a>
	</li>

	<li>
		<a href="../../files/System/Require.html">System/Require.lua</a>
	</li>

	<li>
		<a href="../../files/System/Service.html">System/Service.lua</a>
	</li>

	<li>
		<a href="../../files/System/User.html">System/User.lua</a>
	</li>

	<li>
		<a href="../../files/System/Windows.html">System/Windows.lua</a>
	</li>

	<li>
		<a href="../../files/System/_Debug.html">System/_Debug.lua</a>
	</li>

	<li>
		<a href="../../files/System/_JohnEllisDebugScript.html">System/_JohnEllisDebugScript.lua</a>
	</li>

	<li>
		<a href="../../files/System/_JohnEllisRequire.html">System/_JohnEllisRequire.lua</a>
	</li>

	<li>
		<a href="../../files/System/_Load.html">System/_Load.lua</a>
	</li>

	<li>
		<a href="../../files/System/_Loader.html">System/_Loader.lua</a>
	</li>

	<li>
		<a href="../../files/System/_ObjectFactory.html">System/_ObjectFactory.lua</a>
	</li>

	<li>
		<a href="../../files/System/__Debug.html">System/__Debug.lua</a>
	</li>

</ul>






</div> <!-- id="navigation" -->

<div id="content">

<h1>File <code>Data/String.lua</code></h1>







<h2>Functions</h2>
<table class="function_list">

	<tr>
	<td class="name" nowrap><a href="#String:breakdownPath">String:breakdownPath</a>&nbsp;(path)</td>
	<td class="summary">Break down a path into an array of components.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#String:compare">String:compare</a>&nbsp;(s1, s2)</td>
	<td class="summary">Compare two strings.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#String:compareAll">String:compareAll</a>&nbsp;(s1, s2, count)</td>
	<td class="summary">Compare two strings in their entirety (or until one string runs out of characters).</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#String:format">String:format</a>&nbsp;(s, ...)</td>
	<td class="summary">Format a string using LOC formatter but without localization.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#String:formatAmp">String:formatAmp</a>&nbsp;(s, ...)</td>
	<td class="summary">Same as format plain except converts ampersands for mac compatibility.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#String:formatAmps">String:formatAmps</a>&nbsp;(s, ...)</td>
	<td class="summary">Same as format plain except converts ampersands for windows compatibility.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#String:getBaseName">String:getBaseName</a>&nbsp;(fp)</td>
	<td class="summary">Get filename sans extension from path.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#String:getChar">String:getChar</a>&nbsp;(s, index)</td>
	<td class="summary">Convenience function for getting the n-th character of a string.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#String:getCtrlKeySeq">String:getCtrlKeySeq</a>&nbsp;(key)</td>
	<td class="summary">Get control keyboard sequence for running platform.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#String:getDiff">String:getDiff</a>&nbsp;(s1, s2)</td>
	<td class="summary">Get the difference between two strings.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#String:getFirstChar">String:getFirstChar</a>&nbsp;(s)</td>
	<td class="summary">Convenience function for getting the first character of a string.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#String:getLastChar">String:getLastChar</a>&nbsp;(s)</td>
	<td class="summary">Convenience function for getting the last character of a string.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#String:getNonNegativeNumber">String:getNonNegativeNumber</a>&nbsp;(s)</td>
	<td class="summary">Extract a number from the front of a string.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#String:initPlurals">String:initPlurals</a>&nbsp;()</td>
	<td class="summary">Initializes dictionaries for singular/plural support.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#String:is">String:is</a>&nbsp;(s)</td>
	<td class="summary">Determine if a string value is non-nil or empty.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#String:isEqualIgnoringCase">String:isEqualIgnoringCase</a>&nbsp;(s1, s2)</td>
	<td class="summary">Determine if two strings are equal other than case differences.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#String:isPlural">String:isPlural</a>&nbsp;(word)</td>
	<td class="summary">Determine if a word is singular or plural.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#String:isStartingWith">String:isStartingWith</a>&nbsp;(s, t, ...)</td>
	<td class="summary">Determine if one string starts with another.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#String:isString">String:isString</a>&nbsp;(s)</td>
	<td class="summary">Determine if a value is nil, or if string whether its empty.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#String:lines">String:lines</a>&nbsp;(s, delim)</td>
	<td class="summary">Returns iterator over lines in a string.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#String:loc">String:loc</a>&nbsp;(i18nKey, s, ...)</td>
	<td class="summary">Example: str:loc( "My/Thing", "In English, we say...^1", myvar )  In my opinion, this is just more readable than the LOC syntax.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#String:makePathFromComponents">String:makePathFromComponents</a>&nbsp;(comps)</td>
	<td class="summary">Make path from component array.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#String:makePlural">String:makePlural</a>&nbsp;(word)</td>
	<td class="summary">Makes a word presumed to be singular into its plural form.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#String:makeSingular">String:makeSingular</a>&nbsp;(word)</td>
	<td class="summary">Make a plural form singular.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#String:makeSpace">String:makeSpace</a>&nbsp;(howMany)</td>
	<td class="summary">Makes a string of spaces - used for indentation and output formatting...</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#String:new">String:new</a>&nbsp;(t)</td>
	<td class="summary">Constructor for new instance.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#String:newClass">String:newClass</a>&nbsp;(t)</td>
	<td class="summary">Constructor for extending class.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#String:padLeft">String:padLeft</a>&nbsp;(str, chr, wid)</td>
	<td class="summary">Synopsis:       Pads a string on the left with specified character up to width.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#String:plural">String:plural</a>&nbsp;(count, singular, useNumberForSingular)</td>
	<td class="summary">Return singular or plural count of something.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#String:replaceBackSlashesWithForwardSlashes">String:replaceBackSlashesWithForwardSlashes</a>&nbsp;(_path)</td>
	<td class="summary">Convert windows backslash format to mac/unix/ftp forward-slash notation.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#String:split">String:split</a>&nbsp;(s, delim)</td>
	<td class="summary">Split a string based on delimiter.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#String:squeeze">String:squeeze</a>&nbsp;(s)</td>
	<td class="summary">Remove spaces from middle of a string (as well as ends).</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#String:squeezePath">String:squeezePath</a>&nbsp;(_path, _width)</td>
	<td class="summary">Squeezes a path to fit into fixed width display field.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#String:squeezeToFit">String:squeezeToFit</a>&nbsp;(_str, _width)</td>
	<td class="summary">Squeezes a string to fit into fixed width display field.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#String:to">String:to</a>&nbsp;(var)</td>
	<td class="summary">Return string suitable primarily for short (synopsis-style) debug output and/or display when precise format is not critical.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#String:tokenize">String:tokenize</a>&nbsp;(s, nTokensMax)</td>
	<td class="summary">Breaks a string into tokens by getting rid of the whitespace between them.</td>
	</tr>

</table>






<br/>
<br/>




<h2><a name="functions"></a>Functions</h2>
<dl class="function">



<dt><a name="String:breakdownPath"></a><strong>String:breakdownPath</strong>&nbsp;(path)</dt>
<dd>
Break down a path into an array of components. 


<h3>Parameters:</h3>
<ul>
	
	<li>
	  <code><em>path</em></code>: 
	</li>
	
</ul>




<h3>Usage:</h3>
<ul><pre class=example>Does not distinguish absolute from relative paths. </pre></ul>



<h3>Return value:</h3>
<ul>array (1st component is root), usually not empty, never nil. </ul>



</dd>




<dt><a name="String:compare"></a><strong>String:compare</strong>&nbsp;(s1, s2)</dt>
<dd>
Compare two strings. 


<h3>Parameters:</h3>
<ul>
	
	<li>
	  <code><em>s1</em></code>: 
	</li>
	
	<li>
	  <code><em>s2</em></code>: 
	</li>
	
</ul>




<h3>Usage:</h3>
<ul><pre class=example>Returns immediately upon first difference. </pre></ul>



<h3>Return value:</h3>
<ul>0 if same, else difference position. </ul>



</dd>




<dt><a name="String:compareAll"></a><strong>String:compareAll</strong>&nbsp;(s1, s2, count)</dt>
<dd>
Compare two strings in their entirety (or until one string runs out of characters). 


<h3>Parameters:</h3>
<ul>
	
	<li>
	  <code><em>s1</em></code>: 
	</li>
	
	<li>
	  <code><em>s2</em></code>: 
	</li>
	
	<li>
	  <code><em>count</em></code>: 
	</li>
	
</ul>




<h3>Usage:</h3>
<ul>
	
	<li><pre class=example>Use when it is desired to know the character positions of all the differences.</pre></li>
	
	<li><pre class=example>Most appropriate when the files are same length, or at least start off the same, since there is no attempt to resynchronize... </pre></li>
	
</ul>



<h3>Return value:</h3>
<ul>nil if same, else array of difference indexes. </ul>



</dd>




<dt><a name="String:format"></a><strong>String:format</strong>&nbsp;(s, ...)</dt>
<dd>
Format a string using LOC formatter but without localization. 


<h3>Parameters:</h3>
<ul>
	
	<li>
	  <code><em>s</em></code>: 
	</li>
	
	<li>
	  <code><em>...</em></code>: 
	</li>
	
</ul>




<h3>Usage:</h3>
<ul><pre class=example>An alternative to lua string.format function (which uses ansi 'C' printf syntax). </pre></ul>





</dd>




<dt><a name="String:formatAmp"></a><strong>String:formatAmp</strong>&nbsp;(s, ...)</dt>
<dd>
Same as format plain except converts ampersands for mac compatibility.  Assumes they are formatted for Windows compatibility upon entry (double '&&' ).  Pros: More efficient on windows. Cons: Less efficient on Mac, & less readable. 


<h3>Parameters:</h3>
<ul>
	
	<li>
	  <code><em>s</em></code>: 
	</li>
	
	<li>
	  <code><em>...</em></code>: 
	</li>
	
</ul>








</dd>




<dt><a name="String:formatAmps"></a><strong>String:formatAmps</strong>&nbsp;(s, ...)</dt>
<dd>
Same as format plain except converts ampersands for windows compatibility.  Assumes they are formatted for Mac compatibility upon entry (single '&' ).  Pros: More readable on all platforms. Cons: Less efficient on Windows. 


<h3>Parameters:</h3>
<ul>
	
	<li>
	  <code><em>s</em></code>: 
	</li>
	
	<li>
	  <code><em>...</em></code>: 
	</li>
	
</ul>








</dd>




<dt><a name="String:getBaseName"></a><strong>String:getBaseName</strong>&nbsp;(fp)</dt>
<dd>
Get filename sans extension from path. 


<h3>Parameters:</h3>
<ul>
	
	<li>
	  <code><em>fp</em></code>: 
	</li>
	
</ul>




<h3>Usage:</h3>
<ul><pre class=example>*** this failed when I tried these ops in reverse, i.e. removing extension of leaf-name not sure why. Hmmm... </pre></ul>





</dd>




<dt><a name="String:getChar"></a><strong>String:getChar</strong>&nbsp;(s, index)</dt>
<dd>
Convenience function for getting the n-th character of a string. 


<h3>Parameters:</h3>
<ul>
	
	<li>
	  <code><em>s</em></code>: The string.
	</li>
	
	<li>
	  <code><em>index</em></code>: First char is index 1. 
	</li>
	
</ul>




<h3>Usage:</h3>
<ul><pre class=example>@2010-11-23: *** Will throw error if index is out of bounds, so check before calling if unsure. </pre></ul>



<h3>Return value:</h3>
<ul>character in string. </ul>



</dd>




<dt><a name="String:getCtrlKeySeq"></a><strong>String:getCtrlKeySeq</strong>&nbsp;(key)</dt>
<dd>
Get control keyboard sequence for running platform.  <p>Purpose is so Mac users don't have to be bothered with Windows syntax, nor vice versa.</p> 


<h3>Parameters:</h3>
<ul>
	
	<li>
	  <code><em>key</em></code>: 
	</li>
	
</ul>




<h3>Usage:</h3>
<ul>
	
	<li><pre class=example>Not for issuing keystrokes but for prompting user.</pre></li>
	
	<li><pre class=example>For example: str:format( 'Press ^1 to save metadata first...', str:getCtrlKeySeq( 's' ) ) </pre></li>
	
</ul>





</dd>




<dt><a name="String:getDiff"></a><strong>String:getDiff</strong>&nbsp;(s1, s2)</dt>
<dd>
Get the difference between two strings. 


<h3>Parameters:</h3>
<ul>
	
	<li>
	  <code><em>s1</em></code>: 
	</li>
	
	<li>
	  <code><em>s2</em></code>: 
	</li>
	
</ul>




<h3>Usage:</h3>
<ul><pre class=example>Use to see the difference between two strings. </pre></ul>



<h3>Return values:</h3>
<ol>
	
	<li>diff-len</li>
	
	<li>s1-remainder</li>
	
	<li>s2-remainder </li>
	
</ol>



</dd>




<dt><a name="String:getFirstChar"></a><strong>String:getFirstChar</strong>&nbsp;(s)</dt>
<dd>
Convenience function for getting the first character of a string. 


<h3>Parameters:</h3>
<ul>
	
	<li>
	  <code><em>s</em></code>: 
	</li>
	
</ul>




<h3>Usage:</h3>
<ul><pre class=example>throws error if string does not have a first character, so check before calling if necessary. </pre></ul>





</dd>




<dt><a name="String:getLastChar"></a><strong>String:getLastChar</strong>&nbsp;(s)</dt>
<dd>
Convenience function for getting the last character of a string. 


<h3>Parameters:</h3>
<ul>
	
	<li>
	  <code><em>s</em></code>: 
	</li>
	
</ul>




<h3>Usage:</h3>
<ul><pre class=example>throws error if string does not have a last character, so check before calling if necessary. </pre></ul>





</dd>




<dt><a name="String:getNonNegativeNumber"></a><strong>String:getNonNegativeNumber</strong>&nbsp;(s)</dt>
<dd>
Extract a number from the front of a string.  <p>Initial application for ordering strings that start with a number.</p> 


<h3>Parameters:</h3>
<ul>
	
	<li>
	  <code><em>s</em></code>: 
	</li>
	
</ul>




<h3>Usage:</h3>
<ul><pre class=example>*** Warning: Does NOT check incoming string or parse position. </pre></ul>



<h3>Return value:</h3>
<ul>Next parse position. </ul>



</dd>




<dt><a name="String:initPlurals"></a><strong>String:initPlurals</strong>&nbsp;()</dt>
<dd>
Initializes dictionaries for singular/plural support.  <p>May never be called if plugin does not call at least one plural function.</p> 





<h3>Usage:</h3>
<ul><pre class=example>Could be called in plugin-init, or in string constructor - but isn't. - will be called on first demand. </pre></ul>





</dd>




<dt><a name="String:is"></a><strong>String:is</strong>&nbsp;(s)</dt>
<dd>
Determine if a string value is non-nil or empty.  <p>Convenience function to avoid checking both aspects, or getting a "expected string, got nil" error.</p> 


<h3>Parameters:</h3>
<ul>
	
	<li>
	  <code><em>s</em></code>: 
	</li>
	
</ul>




<h3>Usage:</h3>
<ul>
	
	<li><pre class=example>If value type is not known to be string if not nil, then use 'really-is' instead.</pre></li>
	
	<li><pre class=example>Throws error if type is not string or nil. </pre></li>
	
</ul>



<h3>Return value:</h3>
<ul>true iff non-empty string. </ul>



</dd>




<dt><a name="String:isEqualIgnoringCase"></a><strong>String:isEqualIgnoringCase</strong>&nbsp;(s1, s2)</dt>
<dd>
Determine if two strings are equal other than case differences. 


<h3>Parameters:</h3>
<ul>
	
	<li>
	  <code><em>s1</em></code>: 
	</li>
	
	<li>
	  <code><em>s2</em></code>: 
	</li>
	
</ul>








</dd>




<dt><a name="String:isPlural"></a><strong>String:isPlural</strong>&nbsp;(word)</dt>
<dd>
Determine if a word is singular or plural.  <p>Note: It is possible for some plurals to escape detection. Not to be used when ascertainment is critical - intention is more for aesthetics...</p> 


<h3>Parameters:</h3>
<ul>
	
	<li>
	  <code><em>word</em></code>: 
	</li>
	
</ul>




<h3>Usage:</h3>
<ul><pre class=example>trim beforehand if necessary. </pre></ul>



<h3>Return value:</h3>
<ul>true iff word is plural. </ul>



</dd>




<dt><a name="String:isStartingWith"></a><strong>String:isStartingWith</strong>&nbsp;(s, t, ...)</dt>
<dd>
Determine if one string starts with another.  <p>Avoids the problem of using the nil returned by string.find in a context that does not like it.</p> 


<h3>Parameters:</h3>
<ul>
	
	<li>
	  <code><em>s</em></code>: 
	</li>
	
	<li>
	  <code><em>t</em></code>: 
	</li>
	
	<li>
	  <code><em>...</em></code>: 
	</li>
	
</ul>




<h3>Usage:</h3>
<ul>
	
	<li><pre class=example>Does not check incoming strings.</pre></li>
	
	<li><pre class=example>Does not ignore whitespace. </pre></li>
	
</ul>



<h3>Return value:</h3>
<ul>true iff s begins with t in character position 1. </ul>



</dd>




<dt><a name="String:isString"></a><strong>String:isString</strong>&nbsp;(s)</dt>
<dd>
Determine if a value is nil, or if string whether its empty.  <p>Avoids checking aspects individually, or getting a "expected string, got nil or boolean" error. 


<h3>Parameters:</h3>
<ul>
	
	<li>
	  <code><em>s</em></code>: 
	</li>
	
</ul>




<h3>Usage:</h3>
<ul><pre class=example>Also weathers the case when s is a table (or number?) </pre></ul>





</dd>




<dt><a name="String:lines"></a><strong>String:lines</strong>&nbsp;(s, delim)</dt>
<dd>
Returns iterator over lines in a string.  <p>For those times when you already have a file's contents as a string and you want to iterate its lines. This essential does the same thing as Lua's io.lines function.</p> 


<h3>Parameters:</h3>
<ul>
	
	<li>
	  <code><em>s</em></code>: 
	</li>
	
	<li>
	  <code><em>delim</em></code>: 
	</li>
	
</ul>




<h3>Usage:</h3>
<ul>
	
	<li><pre class=example>Handles \n or \r\n dynamically as EOL sequence.</pre></li>
	
	<li><pre class=example>Does not handle Mac legacy (\r alone) EOL sequence.</pre></li>
	
	<li><pre class=example>Works as well on binary as text file - no need to read as text file unless the lines must be zero-byte free. </pre></li>
	
</ul>





</dd>




<dt><a name="String:loc"></a><strong>String:loc</strong>&nbsp;(i18nKey, s, ...)</dt>
<dd>
Example: str:loc( "My/Thing", "In English, we say...^1", myvar )  In my opinion, this is just more readable than the LOC syntax. 


<h3>Parameters:</h3>
<ul>
	
	<li>
	  <code><em>i18nKey</em></code>: 
	</li>
	
	<li>
	  <code><em>s</em></code>: 
	</li>
	
	<li>
	  <code><em>...</em></code>: 
	</li>
	
</ul>








</dd>




<dt><a name="String:makePathFromComponents"></a><strong>String:makePathFromComponents</strong>&nbsp;(comps)</dt>
<dd>
Make path from component array. 


<h3>Parameters:</h3>
<ul>
	
	<li>
	  <code><em>comps</em></code>: The array of path components: 1st element is root, last element is child. 
	</li>
	
</ul>








</dd>




<dt><a name="String:makePlural"></a><strong>String:makePlural</strong>&nbsp;(word)</dt>
<dd>
Makes a word presumed to be singular into its plural form. 


<h3>Parameters:</h3>
<ul>
	
	<li>
	  <code><em>word</em></code>: 
	</li>
	
</ul>




<h3>Usage:</h3>
<ul><pre class=example>Call is-plural and trim beforehand if necessary. </pre></ul>





</dd>




<dt><a name="String:makeSingular"></a><strong>String:makeSingular</strong>&nbsp;(word)</dt>
<dd>
Make a plural form singular. 


<h3>Parameters:</h3>
<ul>
	
	<li>
	  <code><em>word</em></code>: 
	</li>
	
</ul>




<h3>Usage:</h3>
<ul><pre class=example>If unsure whether already singular, call is-plural before-hand, and trim if necessary. </pre></ul>





</dd>




<dt><a name="String:makeSpace"></a><strong>String:makeSpace</strong>&nbsp;(howMany)</dt>
<dd>
Makes a string of spaces - used for indentation and output formatting... 


<h3>Parameters:</h3>
<ul>
	
	<li>
	  <code><em>howMany</em></code>: 
	</li>
	
</ul>




<h3>Usage:</h3>
<ul><pre class=example>Not very efficient so use sparingly. </pre></ul>





</dd>




<dt><a name="String:new"></a><strong>String:new</strong>&nbsp;(t)</dt>
<dd>
Constructor for new instance. 


<h3>Parameters:</h3>
<ul>
	
	<li>
	  <code><em>t</em></code>: 
	</li>
	
</ul>








</dd>




<dt><a name="String:newClass"></a><strong>String:newClass</strong>&nbsp;(t)</dt>
<dd>
Constructor for extending class. 


<h3>Parameters:</h3>
<ul>
	
	<li>
	  <code><em>t</em></code>: 
	</li>
	
</ul>








</dd>




<dt><a name="String:padLeft"></a><strong>String:padLeft</strong>&nbsp;(str, chr, wid)</dt>
<dd>
Synopsis:       Pads a string on the left with specified character up to width.  Motivation:     Typically used with spaces for tabular display, or 0s when string represents a number. 


<h3>Parameters:</h3>
<ul>
	
	<li>
	  <code><em>str</em></code>: 
	</li>
	
	<li>
	  <code><em>chr</em></code>: 
	</li>
	
	<li>
	  <code><em>wid</em></code>: 
	</li>
	
</ul>








</dd>




<dt><a name="String:plural"></a><strong>String:plural</strong>&nbsp;(count, singular, useNumberForSingular)</dt>
<dd>
Return singular or plural count of something.  <p>Could be enhanced to force case of singular explicitly, instead of just adaptive.</p> 


<h3>Parameters:</h3>
<ul>
	
	<li>
	  <code><em>count</em></code>: Actual number of things.
	</li>
	
	<li>
	  <code><em>singular</em></code>: The singular form to be used if count is 1.
	</li>
	
	<li>
	  <code><em>useNumberForSingular</em></code>: may be boolean or string<blockquote> boolean true => use numeric form of singular for better aesthetics.<br> string 'u' or 'upper' => use upper case of singular (first char only).<br> string 'l' or 'lower' => use lower case of singular (first char only).<br> default is adaptive case.</blockquote> 
	</li>
	
</ul>




<h3>Usage:</h3>
<ul>
	
	<li><pre class=example>Example: str:format( "^1 rendered.", str:plural( nRendered, "photo" ) ) - "one photo" or "2 photos"</pre></li>
	
	<li><pre class=example>Case is adaptive when word form of singular is used. For example: str:plural( nRendered, "Photo" ) - yields "One Photo". </pre></li>
	
</ul>





</dd>




<dt><a name="String:replaceBackSlashesWithForwardSlashes"></a><strong>String:replaceBackSlashesWithForwardSlashes</strong>&nbsp;(_path)</dt>
<dd>
Convert windows backslash format to mac/unix/ftp forward-slash notation. 


<h3>Parameters:</h3>
<ul>
	
	<li>
	  <code><em>_path</em></code>: 
	</li>
	
</ul>




<h3>Usage:</h3>
<ul>
	
	<li><pre class=example>Prefer lr-path-utils - standardize-path to assure path to disk file is in proper format for localhost.</pre></li>
	
	<li><pre class=example>This function is primarily used for converting windows sub-paths for use in FTP. <br>Lightroom is pretty good about allowing mixtures of forward and backward slashes in ftp functions, <br>but still - I find it more pleasing to handle explicitly. </pre></li>
	
</ul>





</dd>




<dt><a name="String:split"></a><strong>String:split</strong>&nbsp;(s, delim)</dt>
<dd>
Split a string based on delimiter. 


<h3>Parameters:</h3>
<ul>
	
	<li>
	  <code><em>s</em></code>: The string to be split
	</li>
	
	<li>
	  <code><em>delim</em></code>: The delimiter string. Often something like ','. 
	</li>
	
</ul>




<h3>Usage:</h3>
<ul>
	
	<li><pre class=example>Seems like there should be a lua or lr function to do this, but I haven't seen it.</pre></li>
	
	<li><pre class=example>Components may be empty strings - if repeating delimiters exist. </pre></li>
	
</ul>



<h3>Return value:</h3>
<ul>Array of trimmed components - never nil nor empty table unless input is nil or empty string, respectively. </ul>



</dd>




<dt><a name="String:squeeze"></a><strong>String:squeeze</strong>&nbsp;(s)</dt>
<dd>
Remove spaces from middle of a string (as well as ends). 


<h3>Parameters:</h3>
<ul>
	
	<li>
	  <code><em>s</em></code>: 
	</li>
	
</ul>




<h3>Usage:</h3>
<ul><pre class=example>Convenience function to make more readable than testing for nil followed by gsub. </pre></ul>



<h3>Return value:</h3>
<ul>Squeezed string, nil -> empty. </ul>



</dd>




<dt><a name="String:squeezePath"></a><strong>String:squeezePath</strong>&nbsp;(_path, _width)</dt>
<dd>
Squeezes a path to fit into fixed width display field.  <p>One could argue for another parameter that selects a balance between first part of path, and second part of path<br> i.e. balance = 0 => select first part only, balance = 1 => prefer trailing path, .5 => split equally between first and last part of path.</p> <p>Although its conceivable that some pathing may be preferred over long filename, that solution is waiting for a problem...</p> 


<h3>Parameters:</h3>
<ul>
	
	<li>
	  <code><em>_path</em></code>: 
	</li>
	
	<li>
	  <code><em>_width</em></code>: 
	</li>
	
</ul>




<h3>Usage:</h3>
<ul>
	
	<li><pre class=example>Guaranteed to get entire filename, and as much of first part of path as possible.</pre></li>
	
	<li><pre class=example>Lightroom does something similar for progress caption, but algorithm is different. </pre></li>
	
</ul>



<h3>Return value:</h3>
<ul>first-part-of-path.../filename. </ul>



</dd>




<dt><a name="String:squeezeToFit"></a><strong>String:squeezeToFit</strong>&nbsp;(_str, _width)</dt>
<dd>
Squeezes a string to fit into fixed width display field. 


<h3>Parameters:</h3>
<ul>
	
	<li>
	  <code><em>_str</em></code>: 
	</li>
	
	<li>
	  <code><em>_width</em></code>: 
	</li>
	
</ul>






<h3>Return value:</h3>
<ul>first half ... last half </ul>



</dd>




<dt><a name="String:to"></a><strong>String:to</strong>&nbsp;(var)</dt>
<dd>
Return string suitable primarily for short (synopsis-style) debug output and/or display when precise format is not critical.  Feel free to pass a nil value and let 'nil' be returned.  If object has an explicit to-string method, then it will be called, otherwise the lua global function.  Use dump methods for objects and/or log-table..., if more verbose output is desired. 


<h3>Parameters:</h3>
<ul>
	
	<li>
	  <code><em>var</em></code>: 
	</li>
	
</ul>








</dd>




<dt><a name="String:tokenize"></a><strong>String:tokenize</strong>&nbsp;(s, nTokensMax)</dt>
<dd>
Breaks a string into tokens by getting rid of the whitespace between them. 


<h3>Parameters:</h3>
<ul>
	
	<li>
	  <code><em>s</em></code>: - string to tokenize.
	</li>
	
	<li>
	  <code><em>nTokensMax</em></code>: - remainder of string returned as single token once this many tokens found in the first part of the string. 
	</li>
	
</ul>




<h3>Usage:</h3>
<ul><pre class=example>Does similar thing as "split", except delimiter is any whitespace, not just true spaces. </pre></ul>





</dd>


</dl>







</div> <!-- id="content" -->

</div> <!-- id="main" -->

<div id="about">
	<p><a href="http://validator.w3.org/check?uri=referer"><img src="http://www.w3.org/Icons/valid-xhtml10" alt="Valid XHTML 1.0!" height="31" width="88" /></a></p>
</div> <!-- id="about" -->

</div> <!-- id="container" -->	
</body>
</html>
